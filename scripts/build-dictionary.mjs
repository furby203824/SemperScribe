
import fs from 'fs/promises';
import path from 'path';

const filesToParse = [
  'docs/SecNav5216/Phrases, Sentences, or Groups of Sentences.md',
  'docs/SecNav5216/Abbreviations, Acronyms, Short Titles.md',
  'docs/SecNav5216/Lists of Acronyms and Abbreviations.md',
];

const outputFilePath = 'src/lib/military-dictionary.ts';
const wordSetOutputPath = 'src/lib/military-wordset.ts';

async function parseTable(content) {
  const lines = content.split('\n');
  const terms = [];
  const rowRegex = /\|(.+?)\|(.+?)\|/;

  for (const line of lines) {
    if (line.includes('---')) continue;
    const match = line.match(rowRegex);
    if (match) {
      const term = match[1].trim().replace(/(\n|\r)/g, ' ').replace(/(\s{2,})/g, ' ').replace(/(\*\*|\*)/g, '');
      const meaning = match[2].trim().replace(/(\n|\r)/g, ' ').replace(/(\s{2,})/g, ' ');
      if (term && meaning && term !== 'PHRASE EQUIVALENT' && term !== 'Full Title' && term !== 'Term' && term !== 'Course Name' && term !== ':---' && meaning !== ':---') {
        terms.push({ term, meaning });
      }
    }
  }
  return terms;
}

/**
 * Extract individual words from all dictionary entries to build
 * a military-aware word set for spell checking.
 */
function buildWordSet(allTerms) {
  const words = new Set();

  for (const entry of allTerms) {
    // Add the full term (useful for multi-word terms like "ANGLICO")
    const termClean = entry.term.replace(/[()]/g, '').trim();
    if (termClean.length >= 2) {
      words.add(termClean.toUpperCase());
    }

    // Split term into individual words and add each
    const termWords = termClean.split(/[\s/,\-]+/);
    for (const w of termWords) {
      const clean = w.replace(/[^A-Za-z0-9&']/g, '');
      if (clean.length >= 2) {
        words.add(clean.toUpperCase());
      }
    }

    // Also extract words from the meaning/abbreviation column
    const meaningClean = entry.meaning.replace(/[()]/g, '').trim();
    if (meaningClean.length >= 2) {
      words.add(meaningClean.toUpperCase());
    }
    const meaningWords = meaningClean.split(/[\s/,\-]+/);
    for (const w of meaningWords) {
      const clean = w.replace(/[^A-Za-z0-9&']/g, '');
      if (clean.length >= 2) {
        words.add(clean.toUpperCase());
      }
    }
  }

  return Array.from(words).sort();
}

async function buildDictionary() {
  let allTerms = [];
  const projectRoot = process.cwd();

  for (const file of filesToParse) {
    try {
      const filePath = path.join(projectRoot, file);
      const content = await fs.readFile(filePath, 'utf-8');
      const parsedTerms = await parseTable(content);
      allTerms.push(...parsedTerms);
      console.log(`  Parsed ${parsedTerms.length} entries from ${file}`);
    } catch (error) {
      console.error(`Error processing ${file}:`, error);
    }
  }

  const uniqueTerms = Array.from(new Map(allTerms.map(item => [item.term, item])).values());
  uniqueTerms.sort((a, b) => a.term.localeCompare(b.term));

  // Write the dictionary file
  const tsContent = `// This file is auto-generated by scripts/build-dictionary.mjs
// Do not edit this file directly.

export interface DictionaryEntry {
  term: string;
  meaning: string;
}

export const militaryDictionary: DictionaryEntry[] = ${JSON.stringify(uniqueTerms, null, 2)};
`;

  try {
    const outputPath = path.join(projectRoot, outputFilePath);
    await fs.writeFile(outputPath, tsContent, 'utf-8');
    console.log(`Successfully built dictionary with ${uniqueTerms.length} terms to ${outputFilePath}`);
  } catch (error) {
    console.error(`Error writing dictionary file:`, error);
  }

  // Build and write the word set for spell checking
  const wordSet = buildWordSet(uniqueTerms);

  const wordSetContent = `// This file is auto-generated by scripts/build-dictionary.mjs
// Do not edit this file directly.
// Military terms, acronyms, and abbreviations recognized by the spell checker.

export const MILITARY_WORDS: string[] = ${JSON.stringify(wordSet, null, 2)};

/** Fast lookup set â€“ initialized lazily on first use. */
let _set: Set<string> | null = null;
export function getMilitaryWordSet(): Set<string> {
  if (!_set) {
    _set = new Set(MILITARY_WORDS);
  }
  return _set;
}
`;

  try {
    const wordSetPath = path.join(projectRoot, wordSetOutputPath);
    await fs.writeFile(wordSetPath, wordSetContent, 'utf-8');
    console.log(`Successfully built word set with ${wordSet.length} unique words to ${wordSetOutputPath}`);
  } catch (error) {
    console.error(`Error writing word set file:`, error);
  }
}

buildDictionary();
